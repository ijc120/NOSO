# -*- coding: utf-8 -*-
import dash
from dash.dependencies import Input, Output
import dash_core_components as dcc
import dash_html_components as html
import pandas as pd
import flask
import plotly.plotly as py
from plotly import graph_objs as go
import math
from lifetimes import BetaGeoFitter

df = pd.read_csv(
    'https://gist.githubusercontent.com/lksfr/c65d53e66ef45673ce4c8f5ef23e2645/raw/c3dc295facb571959dccc917797158b81d032ac2/CLV.csv',
    index_col=False)

summary2 = pd.read_csv('https://gist.githubusercontent.com/lksfr/cc8488828a89419a50c0486f94f6092a/raw/9c8dfbd080d3a5eaf2b02eab4053c3915156e965/summary2.csv'
    , index_col='Shipping Company')

bgf = BetaGeoFitter()
bgf.load_model('bgf.pkl')

# return html Table with dataframe values  
def generate_table(dataframe, max_rows=50):
    return html.Table(
        # Header
        [html.Tr([html.Th(col) for col in dataframe.columns])] +

        # Body
        [html.Tr([
            html.Td(dataframe.iloc[i][col]) for col in dataframe.columns
        ]) for i in range(min(len(dataframe), max_rows))]
    )


#returns most significant part of a number
def millify(n):
    n = float(n)
    millidx = max(
        0,
        min(
            len(millnames) - 1, int(math.floor(0 if n == 0 else math.log10(abs(n)) / 3))
        ),
    )

    return "{:.0f}{}".format(n / 10 ** (3 * millidx), millnames[millidx])


#returns top indicator div
def indicator(color, text, id_value):
    return html.Div(
        [
            
            html.P(
                text,
                className="twelve columns indicator_text"
            ),
            html.P(
                id = id_value,
                className="indicator_value"
            ),
        ],
        className="four columns indicator",
        
    )

app = dash.Dash()


app.layout = html.Div(
    [
        # header
        html.Div([


          # html.Div(
           # html.Span("USJH Dashboard", className='app-title', style={"color": "black", "padding-bottom": "-40px"}),
           # ),
            html.Div(
                html.Img(src='https://i.ibb.co/G74pSt4/transparant.png',height="100%")
                ,style={"float":"left","height":"100%", "margin-top": "0px"})
            ],
            className="row header",style={"background-color": "#ffffff"}
            ),

        # tabs
        html.Div([

            dcc.Tabs(
                id="tabs",
                style={"height":"20","verticalAlign":"middle", "text-align": "center"},
                children=[
                    dcc.Tab(label="Clustering", value="opportunities_tab"),
                    dcc.Tab(label="CLV", value="leads_tab"),
                    dcc.Tab(id="...",label="Cases", value="cases_tab"),
                ],
                value="leads_tab",
            )

            ],
            className="row tabs_div"
            ),
       
                
        # divs that save dataframe for each tab
       
       


        # Tab content
        html.Div(id="tab_content", className="row", style={"margin": "2% 3%"}),
        
        html.Link(href="https://use.fontawesome.com/releases/v5.2.0/css/all.css",rel="stylesheet"),
        html.Link(href="https://cdn.rawgit.com/plotly/dash-app-stylesheets/2d266c578d2a6e8850ebce48fdb52759b2aef506/stylesheet-oil-and-gas.css",rel="stylesheet"),
        html.Link(href="https://fonts.googleapis.com/css?family=Dosis", rel="stylesheet"),
        html.Link(href="https://fonts.googleapis.com/css?family=Open+Sans", rel="stylesheet"),
        html.Link(href="https://fonts.googleapis.com/css?family=Ubuntu", rel="stylesheet"),
        html.Link(href="https://cdn.rawgit.com/amadoukane96/8a8cfdac5d2cecad866952c52a70a50e/raw/cd5a9bf0b30856f4fc7e3812162c74bfc0ebe011/dash_crm.css", rel="stylesheet"),

        html.H3("Customer Lifetime Value", style={"padding-left": "150px"}),

         dcc.Dropdown(id='dropdown', style={'width': '60%', "padding-left": "150px"}, options=[
            {'label': i, 'value': i} for i in df.ID.unique()
            ], multi=True, placeholder='Filter by customer name...'),

         html.Div([
                html.H3("Customer Return Probability"),

                dcc.Dropdown(
                     id='customer_prob',
                         options=[
                         {'label': i, 'value': i} for i in df.ID.unique()
                        ],
                    placeholder='Select customer...'
                ),

                html.P(style={"margin-top": "17px"}),

                dcc.Slider(
                        id='slider',
                        min=0,
                        max=12,
                        marks={i: 'Month {}'.format(i) if i == 1 else str(i) for i in range(1, 13)},
                        value=5,

                    ),
                html.Br(),
                html.Br(),

                html.Div(id='result', style={"width": "400px"})


                ]

                ,style={"float":"right","padding-right": "150px", "margin-top": "-105px"}
                ),

         html.Br(),

         dcc.Dropdown(id='dropdown2', style={'width': '60%', "padding-left": "150px"}, options=[
            {'label': i, 'value': i} for i in df.Target_Group.unique()
            ], multi=True, placeholder='Filter by target group...'),


        html.Div(id='table-container', style={'width': '36%', "padding-left": "150px"})
            ],
            className="row",
            style={"margin": "0%"}
)

@app.callback(
    dash.dependencies.Output('table-container', 'children'),
    [Input('dropdown', 'value'), Input('dropdown2', 'value')])
def display_table(dropdown, dropdown2):
    if dropdown is None and dropdown2 is None:
        return generate_table(df)


    dff = df[(df['Target_Group'].str.contains('|'.join(dropdown2))) & (df['ID'].str.contains('|'.join(dropdown)))]
    return generate_table(dff)


@app.callback(
    Output('result', 'children'),
    [Input('customer_prob', 'value'), Input('slider', 'value')])
def customer_order_prob(name, periods=1):
    if name is not None:
        try:
            t = periods
            individual = summary2.loc[name]
            individual_id = summary2.loc[name].index
            probability = bgf.predict(t, individual['frequency'], individual['recency'], individual['T'])
            return('This customer will make {:.2f} repeat purchases over the course of '.format(probability) + str(periods) + ' months.')
        except ValueError:
            return 'Invalid Input'


@app.callback(Output("tab_content", "children"), [Input("tabs", "value")])
def render_content(tab):
    if tab == "opportunities_tab":
        return opportunities.layout
    elif tab == "cases_tab":
        return cases.layout
    elif tab == "leads_tab":
        return leads.layout
    else:
        return opportunities.layout

if __name__ == "__main__":
    app.run_server(debug=True)